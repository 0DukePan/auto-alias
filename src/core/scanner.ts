import * as fs from "fs"
import * as path from "path"
import { glob } from "fast-glob"
import type { AliasConfig, ScanOptions } from "../types"

export class ProjectScanner {
  private rootDir: string
  private options: Required<ScanOptions>

  constructor(rootDir: string, options: ScanOptions = {}) {
    this.rootDir = rootDir
    this.options = {
      srcDir: options.srcDir || "src",
      excludeDirs: options.excludeDirs || ["node_modules", ".git", "dist", "build"],
      minDepth: options.minDepth || 1,
      maxDepth: options.maxDepth || 4,
      prefix: options.prefix || "@",
    }
  }

  async scanForAliases(): Promise<AliasConfig[]> {
    const srcPath = path.join(this.rootDir, this.options.srcDir)

    // Create src directory if it doesn't exist
    if (!fs.existsSync(srcPath)) {
      console.log(`Creating source directory: ${srcPath}`)
      fs.mkdirSync(srcPath, { recursive: true })

      // Create a basic index.ts file
      const indexPath = path.join(srcPath, "index.ts")
      fs.writeFileSync(
        indexPath,
        `// Auto-generated by auto-ts-alias
// This is your main entry point
export {};
`,
        "utf8",
      )

      // Create some common directories
      const commonDirs = ["components", "utils", "types"]
      for (const dir of commonDirs) {
        const dirPath = path.join(srcPath, dir)
        fs.mkdirSync(dirPath, { recursive: true })

        // Create index files in each directory
        const indexFile = path.join(dirPath, "index.ts")
        fs.writeFileSync(
          indexFile,
          `// ${dir} module
export {};
`,
          "utf8",
        )
      }

      console.log(`Created basic project structure in ${srcPath}`)
    }

    const aliases: AliasConfig[] = []

    // Get all directories in src
    const pattern = path.join(srcPath, "**").replace(/\\/g, "/")
    const directories = await glob(pattern, {
      onlyDirectories: true,
      ignore: this.options.excludeDirs.map((dir) => `**/${dir}/**`),
      deep: this.options.maxDepth,
    })

    for (const dir of directories) {
      const relativePath = path.relative(srcPath, dir)
      const depth = relativePath.split(path.sep).length

      if (depth < this.options.minDepth) continue

      // Generate alias name
      const aliasName = this.generateAliasName(relativePath)
      const aliasPath = path.relative(this.rootDir, dir).replace(/\\/g, "/")

      aliases.push({
        alias: aliasName,
        path: `./${aliasPath}/*`,
        relativePath: relativePath,
      })
    }

    // Add root src alias
    aliases.unshift({
      alias: `${this.options.prefix}/*`,
      path: `./${this.options.srcDir}/*`,
      relativePath: "",
    })

    return this.deduplicateAliases(aliases)
  }

  private generateAliasName(relativePath: string): string {
    const segments = relativePath.split(path.sep)

    // For nested paths, use the last segment
    if (segments.length === 1) {
      return `${this.options.prefix}${segments[0]}`
    }

    // For deeper nesting, create hierarchical aliases
    return `${this.options.prefix}${segments.join("/")}`
  }

  private deduplicateAliases(aliases: AliasConfig[]): AliasConfig[] {
    const seen = new Set<string>()
    return aliases.filter((alias) => {
      if (seen.has(alias.alias)) return false
      seen.add(alias.alias)
      return true
    })
  }

  async getProjectStructure(): Promise<string[]> {
    const srcPath = path.join(this.rootDir, this.options.srcDir)
    const pattern = path.join(srcPath, "**").replace(/\\/g, "/")

    return await glob(pattern, {
      onlyDirectories: true,
      ignore: this.options.excludeDirs.map((dir) => `**/${dir}/**`),
    })
  }
}