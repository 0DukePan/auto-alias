import * as fs from "fs"
import * as path from "path"
import type { AliasConfig, GeneratorResult } from "../types"
import { parse } from "jsonc-parser"

export class TsConfigGenerator {
  private configPath: string
  private rootDir: string

  constructor(rootDir: string, configPath?: string) {
    this.rootDir = rootDir
    this.configPath = configPath || path.join(rootDir, "tsconfig.json")
  }

  async updatePaths(aliases: AliasConfig[]): Promise<GeneratorResult> {
    try {
      let config: any = {}
      let existingContent = ""

      // Read existing tsconfig.json if it exists
      if (fs.existsSync(this.configPath)) {
        existingContent = fs.readFileSync(this.configPath, "utf8")

        try {
          // Try to parse with a more robust comment removal
          const cleanContent = this.removeJsonComments(existingContent)
          config = JSON.parse(cleanContent)
        } catch (parseError) {
          // If parsing fails, try using jsonc-parser for better JSON-with-comments support
          try {
            config = parse(existingContent) || {}
          } catch (jsoncError) {
            console.warn(`Warning: Could not parse existing tsconfig.json. Creating new configuration.`)
            console.warn(`Parse error: ${(parseError as Error).message}`)
            config = {}
          }
        }
      }

      // Ensure compilerOptions exists
      if (!config.compilerOptions) {
        config.compilerOptions = {}
      }

      // Generate paths object
      const paths: Record<string, string[]> = {}
      aliases.forEach((alias) => {
        paths[alias.alias] = [alias.path]
      })

      // Update paths
      config.compilerOptions.paths = paths

      // Ensure baseUrl is set
      if (!config.compilerOptions.baseUrl) {
        config.compilerOptions.baseUrl = "."
      }

      // Ensure proper include/exclude patterns
      if (!config.include) {
        // Check if src directory exists, if not, look for common source directories
        const srcDir = this.findSourceDirectory()
        config.include = [`${srcDir}/**/*`]
      }

      if (!config.exclude) {
        config.exclude = ["node_modules", "dist", "**/*.test.ts", "**/*.spec.ts"]
      }

      // Ensure basic compiler options for a functional TypeScript project
      const defaultCompilerOptions = {
        target: "ES2020",
        module: "commonjs",
        lib: ["ES2020"],
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        moduleResolution: "node",
      }

      // Merge default options with existing ones (existing takes precedence)
      config.compilerOptions = { ...defaultCompilerOptions, ...config.compilerOptions }

      // Write back to file with proper formatting
      const updatedContent = JSON.stringify(config, null, 2)
      fs.writeFileSync(this.configPath, updatedContent, "utf8")

      return {
        success: true,
        message: `Updated tsconfig.json with ${aliases.length} aliases`,
        aliases,
        filesModified: [this.configPath],
      }
    } catch (error) {
      return {
        success: false,
        message: `Failed to update tsconfig.json: ${(error as Error).message}`,
        errors: [(error as Error).message],
      }
    }
  }

  private findSourceDirectory(): string {
    // Common source directory names to check
    const commonSrcDirs = ["src", "lib", "source", "app"]

    for (const dir of commonSrcDirs) {
      const dirPath = path.join(this.rootDir, dir)
      if (fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {
        return dir
      }
    }

    // If no common source directory found, create src directory
    const srcPath = path.join(this.rootDir, "src")
    if (!fs.existsSync(srcPath)) {
      fs.mkdirSync(srcPath, { recursive: true })

      // Create a simple index.ts file to make the directory valid
      const indexPath = path.join(srcPath, "index.ts")
      if (!fs.existsSync(indexPath)) {
        fs.writeFileSync(
          indexPath,
          `// Auto-generated by auto-ts-alias
export {};
`,
          "utf8",
        )
      }
    }

    return "src"
  }

  private removeJsonComments(content: string): string {
    try {
      // More robust comment removal that preserves string structure
      let result = content

      // Remove single-line comments (// ...) but not inside strings
      result = result.replace(/(?<!["'])\/\/.*$/gm, "")

      // Remove multi-line comments (/* ... */) but not inside strings
      result = result.replace(/\/\*[\s\S]*?\*\//g, "")

      // Clean up any trailing commas that might cause issues
      result = result.replace(/,(\s*[}\]])/g, "$1")

      // Remove any control characters that might cause issues
      result = result.replace(/[\x00-\x1F\x7F]/g, "")

      return result
    } catch (error) {
      // If comment removal fails, return original content
      console.warn("Comment removal failed, using original content")
      return content
    }
  }
}